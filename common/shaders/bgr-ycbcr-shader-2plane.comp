#version 450

layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, r8) uniform writeonly image2D outputImage0;
layout (binding = 2, rg8) uniform writeonly image2D outputImage1;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    uvec2 inputSize;
} pushConstants;

const float Y_OFFSET = 16.0 / 255.0;
const float UV_OFFSET = 128.0 / 255.0;

// BT.709 limited-range RGB -> YCbCr coefficients.
const vec3 Y_COEFF = vec3(0.182586, 0.614231, 0.062007);
const vec3 U_COEFF = vec3(-0.100644, -0.338572, 0.439216);
const vec3 V_COEFF = vec3(0.439216, -0.398942, -0.040274);

shared vec3 rgbTile[16][16];

float toY(vec3 rgb) {
    return clamp(Y_OFFSET + dot(rgb, Y_COEFF), 0.0, 1.0);
}

vec2 toUv(vec3 rgb) {
    return clamp(vec2(
        UV_OFFSET + dot(rgb, U_COEFF),
        UV_OFFSET + dot(rgb, V_COEFF)
    ), 0.0, 1.0);
}

void main() {
    ivec2 inputSize = ivec2(pushConstants.inputSize);
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lid = ivec2(gl_LocalInvocationID.xy);
    ivec2 groupBase = ivec2(gl_WorkGroupID.xy) * ivec2(16, 16);
    bool inBounds = gid.x < inputSize.x && gid.y < inputSize.y;

    vec3 rgb = vec3(0.0);
    if (inBounds) {
        vec4 bgra = imageLoad(inputImage, gid);
        rgb = vec3(bgra.b, bgra.g, bgra.r);
    }

    rgbTile[lid.y][lid.x] = rgb;
    barrier();

    if (!inBounds) {
        imageStore(outputImage0, gid, vec4(Y_OFFSET));
        if (((gid.x | gid.y) & 1) == 0) {
            imageStore(outputImage1, gid / 2, vec4(UV_OFFSET, UV_OFFSET, 0.0, 0.0));
        }
        return;
    }

    imageStore(outputImage0, gid, vec4(toY(rgb)));

    if (((gid.x | gid.y) & 1) == 0) {
        ivec2 maxCoord = inputSize - ivec2(1);
        ivec2 p11 = min(gid + ivec2(1), maxCoord);
        ivec2 l11 = p11 - groupBase;

        vec3 avgRgb = 0.25 * (
            rgb +
            rgbTile[lid.y][l11.x] +
            rgbTile[l11.y][lid.x] +
            rgbTile[l11.y][l11.x]
        );

        vec2 uv = toUv(avgRgb);
        imageStore(outputImage1, gid / 2, vec4(uv, 0.0, 0.0));
    }
}
